{"version":3,"file":"static/7610.f006780b.chunk.js","mappings":"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","sources":["webpack://app/../../node_modules/@graphiql/react/dist/javascript.es.js"],"sourcesContent":["import { g as getDefaultExportFromCjs, r as requireCodemirror } from \"./codemirror.es2.js\";\nfunction _mergeNamespaces(n, m) {\n  for (var i = 0; i < m.length; i++) {\n    const e = m[i];\n    if (typeof e !== \"string\" && !Array.isArray(e)) {\n      for (const k in e) {\n        if (k !== \"default\" && !(k in n)) {\n          const d = Object.getOwnPropertyDescriptor(e, k);\n          if (d) {\n            Object.defineProperty(n, k, d.get ? d : {\n              enumerable: true,\n              get: () => e[k]\n            });\n          }\n        }\n      }\n    }\n  }\n  return Object.freeze(Object.defineProperty(n, Symbol.toStringTag, { value: \"Module\" }));\n}\nvar javascript$2 = { exports: {} };\n(function(module, exports) {\n  (function(mod) {\n    mod(requireCodemirror());\n  })(function(CodeMirror) {\n    CodeMirror.defineMode(\"javascript\", function(config, parserConfig) {\n      var indentUnit = config.indentUnit;\n      var statementIndent = parserConfig.statementIndent;\n      var jsonldMode = parserConfig.jsonld;\n      var jsonMode = parserConfig.json || jsonldMode;\n      var trackScope = parserConfig.trackScope !== false;\n      var isTS = parserConfig.typescript;\n      var wordRE = parserConfig.wordCharacters || /[\\w$\\xa1-\\uffff]/;\n      var keywords = function() {\n        function kw(type2) {\n          return { type: type2, style: \"keyword\" };\n        }\n        var A = kw(\"keyword a\"), B = kw(\"keyword b\"), C = kw(\"keyword c\"), D = kw(\"keyword d\");\n        var operator = kw(\"operator\"), atom = { type: \"atom\", style: \"atom\" };\n        return {\n          \"if\": kw(\"if\"),\n          \"while\": A,\n          \"with\": A,\n          \"else\": B,\n          \"do\": B,\n          \"try\": B,\n          \"finally\": B,\n          \"return\": D,\n          \"break\": D,\n          \"continue\": D,\n          \"new\": kw(\"new\"),\n          \"delete\": C,\n          \"void\": C,\n          \"throw\": C,\n          \"debugger\": kw(\"debugger\"),\n          \"var\": kw(\"var\"),\n          \"const\": kw(\"var\"),\n          \"let\": kw(\"var\"),\n          \"function\": kw(\"function\"),\n          \"catch\": kw(\"catch\"),\n          \"for\": kw(\"for\"),\n          \"switch\": kw(\"switch\"),\n          \"case\": kw(\"case\"),\n          \"default\": kw(\"default\"),\n          \"in\": operator,\n          \"typeof\": operator,\n          \"instanceof\": operator,\n          \"true\": atom,\n          \"false\": atom,\n          \"null\": atom,\n          \"undefined\": atom,\n          \"NaN\": atom,\n          \"Infinity\": atom,\n          \"this\": kw(\"this\"),\n          \"class\": kw(\"class\"),\n          \"super\": kw(\"atom\"),\n          \"yield\": C,\n          \"export\": kw(\"export\"),\n          \"import\": kw(\"import\"),\n          \"extends\": C,\n          \"await\": C\n        };\n      }();\n      var isOperatorChar = /[+\\-*&%=<>!?|~^@]/;\n      var isJsonldKeyword = /^@(context|id|value|language|type|container|list|set|reverse|index|base|vocab|graph)\"/;\n      function readRegexp(stream) {\n        var escaped = false, next, inSet = false;\n        while ((next = stream.next()) != null) {\n          if (!escaped) {\n            if (next == \"/\" && !inSet) return;\n            if (next == \"[\") inSet = true;\n            else if (inSet && next == \"]\") inSet = false;\n          }\n          escaped = !escaped && next == \"\\\\\";\n        }\n      }\n      var type, content;\n      function ret(tp, style, cont2) {\n        type = tp;\n        content = cont2;\n        return style;\n      }\n      function tokenBase(stream, state) {\n        var ch = stream.next();\n        if (ch == '\"' || ch == \"'\") {\n          state.tokenize = tokenString(ch);\n          return state.tokenize(stream, state);\n        } else if (ch == \".\" && stream.match(/^\\d[\\d_]*(?:[eE][+\\-]?[\\d_]+)?/)) {\n          return ret(\"number\", \"number\");\n        } else if (ch == \".\" && stream.match(\"..\")) {\n          return ret(\"spread\", \"meta\");\n        } else if (/[\\[\\]{}\\(\\),;\\:\\.]/.test(ch)) {\n          return ret(ch);\n        } else if (ch == \"=\" && stream.eat(\">\")) {\n          return ret(\"=>\", \"operator\");\n        } else if (ch == \"0\" && stream.match(/^(?:x[\\dA-Fa-f_]+|o[0-7_]+|b[01_]+)n?/)) {\n          return ret(\"number\", \"number\");\n        } else if (/\\d/.test(ch)) {\n          stream.match(/^[\\d_]*(?:n|(?:\\.[\\d_]*)?(?:[eE][+\\-]?[\\d_]+)?)?/);\n          return ret(\"number\", \"number\");\n        } else if (ch == \"/\") {\n          if (stream.eat(\"*\")) {\n            state.tokenize = tokenComment;\n            return tokenComment(stream, state);\n          } else if (stream.eat(\"/\")) {\n            stream.skipToEnd();\n            return ret(\"comment\", \"comment\");\n          } else if (expressionAllowed(stream, state, 1)) {\n            readRegexp(stream);\n            stream.match(/^\\b(([gimyus])(?![gimyus]*\\2))+\\b/);\n            return ret(\"regexp\", \"string-2\");\n          } else {\n            stream.eat(\"=\");\n            return ret(\"operator\", \"operator\", stream.current());\n          }\n        } else if (ch == \"`\") {\n          state.tokenize = tokenQuasi;\n          return tokenQuasi(stream, state);\n        } else if (ch == \"#\" && stream.peek() == \"!\") {\n          stream.skipToEnd();\n          return ret(\"meta\", \"meta\");\n        } else if (ch == \"#\" && stream.eatWhile(wordRE)) {\n          return ret(\"variable\", \"property\");\n        } else if (ch == \"<\" && stream.match(\"!--\") || ch == \"-\" && stream.match(\"->\") && !/\\S/.test(stream.string.slice(0, stream.start))) {\n          stream.skipToEnd();\n          return ret(\"comment\", \"comment\");\n        } else if (isOperatorChar.test(ch)) {\n          if (ch != \">\" || !state.lexical || state.lexical.type != \">\") {\n            if (stream.eat(\"=\")) {\n              if (ch == \"!\" || ch == \"=\") stream.eat(\"=\");\n            } else if (/[<>*+\\-|&?]/.test(ch)) {\n              stream.eat(ch);\n              if (ch == \">\") stream.eat(ch);\n            }\n          }\n          if (ch == \"?\" && stream.eat(\".\")) return ret(\".\");\n          return ret(\"operator\", \"operator\", stream.current());\n        } else if (wordRE.test(ch)) {\n          stream.eatWhile(wordRE);\n          var word = stream.current();\n          if (state.lastType != \".\") {\n            if (keywords.propertyIsEnumerable(word)) {\n              var kw = keywords[word];\n              return ret(kw.type, kw.style, word);\n            }\n            if (word == \"async\" && stream.match(/^(\\s|\\/\\*([^*]|\\*(?!\\/))*?\\*\\/)*[\\[\\(\\w]/, false))\n              return ret(\"async\", \"keyword\", word);\n          }\n          return ret(\"variable\", \"variable\", word);\n        }\n      }\n      function tokenString(quote) {\n        return function(stream, state) {\n          var escaped = false, next;\n          if (jsonldMode && stream.peek() == \"@\" && stream.match(isJsonldKeyword)) {\n            state.tokenize = tokenBase;\n            return ret(\"jsonld-keyword\", \"meta\");\n          }\n          while ((next = stream.next()) != null) {\n            if (next == quote && !escaped) break;\n            escaped = !escaped && next == \"\\\\\";\n          }\n          if (!escaped) state.tokenize = tokenBase;\n          return ret(\"string\", \"string\");\n        };\n      }\n      function tokenComment(stream, state) {\n        var maybeEnd = false, ch;\n        while (ch = stream.next()) {\n          if (ch == \"/\" && maybeEnd) {\n            state.tokenize = tokenBase;\n            break;\n          }\n          maybeEnd = ch == \"*\";\n        }\n        return ret(\"comment\", \"comment\");\n      }\n      function tokenQuasi(stream, state) {\n        var escaped = false, next;\n        while ((next = stream.next()) != null) {\n          if (!escaped && (next == \"`\" || next == \"$\" && stream.eat(\"{\"))) {\n            state.tokenize = tokenBase;\n            break;\n          }\n          escaped = !escaped && next == \"\\\\\";\n        }\n        return ret(\"quasi\", \"string-2\", stream.current());\n      }\n      var brackets = \"([{}])\";\n      function findFatArrow(stream, state) {\n        if (state.fatArrowAt) state.fatArrowAt = null;\n        var arrow = stream.string.indexOf(\"=>\", stream.start);\n        if (arrow < 0) return;\n        if (isTS) {\n          var m = /:\\s*(?:\\w+(?:<[^>]*>|\\[\\])?|\\{[^}]*\\})\\s*$/.exec(stream.string.slice(stream.start, arrow));\n          if (m) arrow = m.index;\n        }\n        var depth = 0, sawSomething = false;\n        for (var pos = arrow - 1; pos >= 0; --pos) {\n          var ch = stream.string.charAt(pos);\n          var bracket = brackets.indexOf(ch);\n          if (bracket >= 0 && bracket < 3) {\n            if (!depth) {\n              ++pos;\n              break;\n            }\n            if (--depth == 0) {\n              if (ch == \"(\") sawSomething = true;\n              break;\n            }\n          } else if (bracket >= 3 && bracket < 6) {\n            ++depth;\n          } else if (wordRE.test(ch)) {\n            sawSomething = true;\n          } else if (/[\"'\\/`]/.test(ch)) {\n            for (; ; --pos) {\n              if (pos == 0) return;\n              var next = stream.string.charAt(pos - 1);\n              if (next == ch && stream.string.charAt(pos - 2) != \"\\\\\") {\n                pos--;\n                break;\n              }\n            }\n          } else if (sawSomething && !depth) {\n            ++pos;\n            break;\n          }\n        }\n        if (sawSomething && !depth) state.fatArrowAt = pos;\n      }\n      var atomicTypes = {\n        \"atom\": true,\n        \"number\": true,\n        \"variable\": true,\n        \"string\": true,\n        \"regexp\": true,\n        \"this\": true,\n        \"import\": true,\n        \"jsonld-keyword\": true\n      };\n      function JSLexical(indented, column, type2, align, prev, info) {\n        this.indented = indented;\n        this.column = column;\n        this.type = type2;\n        this.prev = prev;\n        this.info = info;\n        if (align != null) this.align = align;\n      }\n      function inScope(state, varname) {\n        if (!trackScope) return false;\n        for (var v = state.localVars; v; v = v.next)\n          if (v.name == varname) return true;\n        for (var cx2 = state.context; cx2; cx2 = cx2.prev) {\n          for (var v = cx2.vars; v; v = v.next)\n            if (v.name == varname) return true;\n        }\n      }\n      function parseJS(state, style, type2, content2, stream) {\n        var cc = state.cc;\n        cx.state = state;\n        cx.stream = stream;\n        cx.marked = null, cx.cc = cc;\n        cx.style = style;\n        if (!state.lexical.hasOwnProperty(\"align\"))\n          state.lexical.align = true;\n        while (true) {\n          var combinator = cc.length ? cc.pop() : jsonMode ? expression : statement;\n          if (combinator(type2, content2)) {\n            while (cc.length && cc[cc.length - 1].lex)\n              cc.pop()();\n            if (cx.marked) return cx.marked;\n            if (type2 == \"variable\" && inScope(state, content2)) return \"variable-2\";\n            return style;\n          }\n        }\n      }\n      var cx = { state: null, column: null, marked: null, cc: null };\n      function pass() {\n        for (var i = arguments.length - 1; i >= 0; i--) cx.cc.push(arguments[i]);\n      }\n      function cont() {\n        pass.apply(null, arguments);\n        return true;\n      }\n      function inList(name, list) {\n        for (var v = list; v; v = v.next) if (v.name == name) return true;\n        return false;\n      }\n      function register(varname) {\n        var state = cx.state;\n        cx.marked = \"def\";\n        if (!trackScope) return;\n        if (state.context) {\n          if (state.lexical.info == \"var\" && state.context && state.context.block) {\n            var newContext = registerVarScoped(varname, state.context);\n            if (newContext != null) {\n              state.context = newContext;\n              return;\n            }\n          } else if (!inList(varname, state.localVars)) {\n            state.localVars = new Var(varname, state.localVars);\n            return;\n          }\n        }\n        if (parserConfig.globalVars && !inList(varname, state.globalVars))\n          state.globalVars = new Var(varname, state.globalVars);\n      }\n      function registerVarScoped(varname, context) {\n        if (!context) {\n          return null;\n        } else if (context.block) {\n          var inner = registerVarScoped(varname, context.prev);\n          if (!inner) return null;\n          if (inner == context.prev) return context;\n          return new Context(inner, context.vars, true);\n        } else if (inList(varname, context.vars)) {\n          return context;\n        } else {\n          return new Context(context.prev, new Var(varname, context.vars), false);\n        }\n      }\n      function isModifier(name) {\n        return name == \"public\" || name == \"private\" || name == \"protected\" || name == \"abstract\" || name == \"readonly\";\n      }\n      function Context(prev, vars, block2) {\n        this.prev = prev;\n        this.vars = vars;\n        this.block = block2;\n      }\n      function Var(name, next) {\n        this.name = name;\n        this.next = next;\n      }\n      var defaultVars = new Var(\"this\", new Var(\"arguments\", null));\n      function pushcontext() {\n        cx.state.context = new Context(cx.state.context, cx.state.localVars, false);\n        cx.state.localVars = defaultVars;\n      }\n      function pushblockcontext() {\n        cx.state.context = new Context(cx.state.context, cx.state.localVars, true);\n        cx.state.localVars = null;\n      }\n      pushcontext.lex = pushblockcontext.lex = true;\n      function popcontext() {\n        cx.state.localVars = cx.state.context.vars;\n        cx.state.context = cx.state.context.prev;\n      }\n      popcontext.lex = true;\n      function pushlex(type2, info) {\n        var result = function() {\n          var state = cx.state, indent = state.indented;\n          if (state.lexical.type == \"stat\") indent = state.lexical.indented;\n          else for (var outer = state.lexical; outer && outer.type == \")\" && outer.align; outer = outer.prev)\n            indent = outer.indented;\n          state.lexical = new JSLexical(indent, cx.stream.column(), type2, null, state.lexical, info);\n        };\n        result.lex = true;\n        return result;\n      }\n      function poplex() {\n        var state = cx.state;\n        if (state.lexical.prev) {\n          if (state.lexical.type == \")\")\n            state.indented = state.lexical.indented;\n          state.lexical = state.lexical.prev;\n        }\n      }\n      poplex.lex = true;\n      function expect(wanted) {\n        function exp(type2) {\n          if (type2 == wanted) return cont();\n          else if (wanted == \";\" || type2 == \"}\" || type2 == \")\" || type2 == \"]\") return pass();\n          else return cont(exp);\n        }\n        return exp;\n      }\n      function statement(type2, value) {\n        if (type2 == \"var\") return cont(pushlex(\"vardef\", value), vardef, expect(\";\"), poplex);\n        if (type2 == \"keyword a\") return cont(pushlex(\"form\"), parenExpr, statement, poplex);\n        if (type2 == \"keyword b\") return cont(pushlex(\"form\"), statement, poplex);\n        if (type2 == \"keyword d\") return cx.stream.match(/^\\s*$/, false) ? cont() : cont(pushlex(\"stat\"), maybeexpression, expect(\";\"), poplex);\n        if (type2 == \"debugger\") return cont(expect(\";\"));\n        if (type2 == \"{\") return cont(pushlex(\"}\"), pushblockcontext, block, poplex, popcontext);\n        if (type2 == \";\") return cont();\n        if (type2 == \"if\") {\n          if (cx.state.lexical.info == \"else\" && cx.state.cc[cx.state.cc.length - 1] == poplex)\n            cx.state.cc.pop()();\n          return cont(pushlex(\"form\"), parenExpr, statement, poplex, maybeelse);\n        }\n        if (type2 == \"function\") return cont(functiondef);\n        if (type2 == \"for\") return cont(pushlex(\"form\"), pushblockcontext, forspec, statement, popcontext, poplex);\n        if (type2 == \"class\" || isTS && value == \"interface\") {\n          cx.marked = \"keyword\";\n          return cont(pushlex(\"form\", type2 == \"class\" ? type2 : value), className, poplex);\n        }\n        if (type2 == \"variable\") {\n          if (isTS && value == \"declare\") {\n            cx.marked = \"keyword\";\n            return cont(statement);\n          } else if (isTS && (value == \"module\" || value == \"enum\" || value == \"type\") && cx.stream.match(/^\\s*\\w/, false)) {\n            cx.marked = \"keyword\";\n            if (value == \"enum\") return cont(enumdef);\n            else if (value == \"type\") return cont(typename, expect(\"operator\"), typeexpr, expect(\";\"));\n            else return cont(pushlex(\"form\"), pattern, expect(\"{\"), pushlex(\"}\"), block, poplex, poplex);\n          } else if (isTS && value == \"namespace\") {\n            cx.marked = \"keyword\";\n            return cont(pushlex(\"form\"), expression, statement, poplex);\n          } else if (isTS && value == \"abstract\") {\n            cx.marked = \"keyword\";\n            return cont(statement);\n          } else {\n            return cont(pushlex(\"stat\"), maybelabel);\n          }\n        }\n        if (type2 == \"switch\") return cont(\n          pushlex(\"form\"),\n          parenExpr,\n          expect(\"{\"),\n          pushlex(\"}\", \"switch\"),\n          pushblockcontext,\n          block,\n          poplex,\n          poplex,\n          popcontext\n        );\n        if (type2 == \"case\") return cont(expression, expect(\":\"));\n        if (type2 == \"default\") return cont(expect(\":\"));\n        if (type2 == \"catch\") return cont(pushlex(\"form\"), pushcontext, maybeCatchBinding, statement, poplex, popcontext);\n        if (type2 == \"export\") return cont(pushlex(\"stat\"), afterExport, poplex);\n        if (type2 == \"import\") return cont(pushlex(\"stat\"), afterImport, poplex);\n        if (type2 == \"async\") return cont(statement);\n        if (value == \"@\") return cont(expression, statement);\n        return pass(pushlex(\"stat\"), expression, expect(\";\"), poplex);\n      }\n      function maybeCatchBinding(type2) {\n        if (type2 == \"(\") return cont(funarg, expect(\")\"));\n      }\n      function expression(type2, value) {\n        return expressionInner(type2, value, false);\n      }\n      function expressionNoComma(type2, value) {\n        return expressionInner(type2, value, true);\n      }\n      function parenExpr(type2) {\n        if (type2 != \"(\") return pass();\n        return cont(pushlex(\")\"), maybeexpression, expect(\")\"), poplex);\n      }\n      function expressionInner(type2, value, noComma) {\n        if (cx.state.fatArrowAt == cx.stream.start) {\n          var body = noComma ? arrowBodyNoComma : arrowBody;\n          if (type2 == \"(\") return cont(pushcontext, pushlex(\")\"), commasep(funarg, \")\"), poplex, expect(\"=>\"), body, popcontext);\n          else if (type2 == \"variable\") return pass(pushcontext, pattern, expect(\"=>\"), body, popcontext);\n        }\n        var maybeop = noComma ? maybeoperatorNoComma : maybeoperatorComma;\n        if (atomicTypes.hasOwnProperty(type2)) return cont(maybeop);\n        if (type2 == \"function\") return cont(functiondef, maybeop);\n        if (type2 == \"class\" || isTS && value == \"interface\") {\n          cx.marked = \"keyword\";\n          return cont(pushlex(\"form\"), classExpression, poplex);\n        }\n        if (type2 == \"keyword c\" || type2 == \"async\") return cont(noComma ? expressionNoComma : expression);\n        if (type2 == \"(\") return cont(pushlex(\")\"), maybeexpression, expect(\")\"), poplex, maybeop);\n        if (type2 == \"operator\" || type2 == \"spread\") return cont(noComma ? expressionNoComma : expression);\n        if (type2 == \"[\") return cont(pushlex(\"]\"), arrayLiteral, poplex, maybeop);\n        if (type2 == \"{\") return contCommasep(objprop, \"}\", null, maybeop);\n        if (type2 == \"quasi\") return pass(quasi, maybeop);\n        if (type2 == \"new\") return cont(maybeTarget(noComma));\n        return cont();\n      }\n      function maybeexpression(type2) {\n        if (type2.match(/[;\\}\\)\\],]/)) return pass();\n        return pass(expression);\n      }\n      function maybeoperatorComma(type2, value) {\n        if (type2 == \",\") return cont(maybeexpression);\n        return maybeoperatorNoComma(type2, value, false);\n      }\n      function maybeoperatorNoComma(type2, value, noComma) {\n        var me = noComma == false ? maybeoperatorComma : maybeoperatorNoComma;\n        var expr = noComma == false ? expression : expressionNoComma;\n        if (type2 == \"=>\") return cont(pushcontext, noComma ? arrowBodyNoComma : arrowBody, popcontext);\n        if (type2 == \"operator\") {\n          if (/\\+\\+|--/.test(value) || isTS && value == \"!\") return cont(me);\n          if (isTS && value == \"<\" && cx.stream.match(/^([^<>]|<[^<>]*>)*>\\s*\\(/, false))\n            return cont(pushlex(\">\"), commasep(typeexpr, \">\"), poplex, me);\n          if (value == \"?\") return cont(expression, expect(\":\"), expr);\n          return cont(expr);\n        }\n        if (type2 == \"quasi\") {\n          return pass(quasi, me);\n        }\n        if (type2 == \";\") return;\n        if (type2 == \"(\") return contCommasep(expressionNoComma, \")\", \"call\", me);\n        if (type2 == \".\") return cont(property, me);\n        if (type2 == \"[\") return cont(pushlex(\"]\"), maybeexpression, expect(\"]\"), poplex, me);\n        if (isTS && value == \"as\") {\n          cx.marked = \"keyword\";\n          return cont(typeexpr, me);\n        }\n        if (type2 == \"regexp\") {\n          cx.state.lastType = cx.marked = \"operator\";\n          cx.stream.backUp(cx.stream.pos - cx.stream.start - 1);\n          return cont(expr);\n        }\n      }\n      function quasi(type2, value) {\n        if (type2 != \"quasi\") return pass();\n        if (value.slice(value.length - 2) != \"${\") return cont(quasi);\n        return cont(maybeexpression, continueQuasi);\n      }\n      function continueQuasi(type2) {\n        if (type2 == \"}\") {\n          cx.marked = \"string-2\";\n          cx.state.tokenize = tokenQuasi;\n          return cont(quasi);\n        }\n      }\n      function arrowBody(type2) {\n        findFatArrow(cx.stream, cx.state);\n        return pass(type2 == \"{\" ? statement : expression);\n      }\n      function arrowBodyNoComma(type2) {\n        findFatArrow(cx.stream, cx.state);\n        return pass(type2 == \"{\" ? statement : expressionNoComma);\n      }\n      function maybeTarget(noComma) {\n        return function(type2) {\n          if (type2 == \".\") return cont(noComma ? targetNoComma : target);\n          else if (type2 == \"variable\" && isTS) return cont(maybeTypeArgs, noComma ? maybeoperatorNoComma : maybeoperatorComma);\n          else return pass(noComma ? expressionNoComma : expression);\n        };\n      }\n      function target(_, value) {\n        if (value == \"target\") {\n          cx.marked = \"keyword\";\n          return cont(maybeoperatorComma);\n        }\n      }\n      function targetNoComma(_, value) {\n        if (value == \"target\") {\n          cx.marked = \"keyword\";\n          return cont(maybeoperatorNoComma);\n        }\n      }\n      function maybelabel(type2) {\n        if (type2 == \":\") return cont(poplex, statement);\n        return pass(maybeoperatorComma, expect(\";\"), poplex);\n      }\n      function property(type2) {\n        if (type2 == \"variable\") {\n          cx.marked = \"property\";\n          return cont();\n        }\n      }\n      function objprop(type2, value) {\n        if (type2 == \"async\") {\n          cx.marked = \"property\";\n          return cont(objprop);\n        } else if (type2 == \"variable\" || cx.style == \"keyword\") {\n          cx.marked = \"property\";\n          if (value == \"get\" || value == \"set\") return cont(getterSetter);\n          var m;\n          if (isTS && cx.state.fatArrowAt == cx.stream.start && (m = cx.stream.match(/^\\s*:\\s*/, false)))\n            cx.state.fatArrowAt = cx.stream.pos + m[0].length;\n          return cont(afterprop);\n        } else if (type2 == \"number\" || type2 == \"string\") {\n          cx.marked = jsonldMode ? \"property\" : cx.style + \" property\";\n          return cont(afterprop);\n        } else if (type2 == \"jsonld-keyword\") {\n          return cont(afterprop);\n        } else if (isTS && isModifier(value)) {\n          cx.marked = \"keyword\";\n          return cont(objprop);\n        } else if (type2 == \"[\") {\n          return cont(expression, maybetype, expect(\"]\"), afterprop);\n        } else if (type2 == \"spread\") {\n          return cont(expressionNoComma, afterprop);\n        } else if (value == \"*\") {\n          cx.marked = \"keyword\";\n          return cont(objprop);\n        } else if (type2 == \":\") {\n          return pass(afterprop);\n        }\n      }\n      function getterSetter(type2) {\n        if (type2 != \"variable\") return pass(afterprop);\n        cx.marked = \"property\";\n        return cont(functiondef);\n      }\n      function afterprop(type2) {\n        if (type2 == \":\") return cont(expressionNoComma);\n        if (type2 == \"(\") return pass(functiondef);\n      }\n      function commasep(what, end, sep) {\n        function proceed(type2, value) {\n          if (sep ? sep.indexOf(type2) > -1 : type2 == \",\") {\n            var lex = cx.state.lexical;\n            if (lex.info == \"call\") lex.pos = (lex.pos || 0) + 1;\n            return cont(function(type3, value2) {\n              if (type3 == end || value2 == end) return pass();\n              return pass(what);\n            }, proceed);\n          }\n          if (type2 == end || value == end) return cont();\n          if (sep && sep.indexOf(\";\") > -1) return pass(what);\n          return cont(expect(end));\n        }\n        return function(type2, value) {\n          if (type2 == end || value == end) return cont();\n          return pass(what, proceed);\n        };\n      }\n      function contCommasep(what, end, info) {\n        for (var i = 3; i < arguments.length; i++)\n          cx.cc.push(arguments[i]);\n        return cont(pushlex(end, info), commasep(what, end), poplex);\n      }\n      function block(type2) {\n        if (type2 == \"}\") return cont();\n        return pass(statement, block);\n      }\n      function maybetype(type2, value) {\n        if (isTS) {\n          if (type2 == \":\") return cont(typeexpr);\n          if (value == \"?\") return cont(maybetype);\n        }\n      }\n      function maybetypeOrIn(type2, value) {\n        if (isTS && (type2 == \":\" || value == \"in\")) return cont(typeexpr);\n      }\n      function mayberettype(type2) {\n        if (isTS && type2 == \":\") {\n          if (cx.stream.match(/^\\s*\\w+\\s+is\\b/, false)) return cont(expression, isKW, typeexpr);\n          else return cont(typeexpr);\n        }\n      }\n      function isKW(_, value) {\n        if (value == \"is\") {\n          cx.marked = \"keyword\";\n          return cont();\n        }\n      }\n      function typeexpr(type2, value) {\n        if (value == \"keyof\" || value == \"typeof\" || value == \"infer\" || value == \"readonly\") {\n          cx.marked = \"keyword\";\n          return cont(value == \"typeof\" ? expressionNoComma : typeexpr);\n        }\n        if (type2 == \"variable\" || value == \"void\") {\n          cx.marked = \"type\";\n          return cont(afterType);\n        }\n        if (value == \"|\" || value == \"&\") return cont(typeexpr);\n        if (type2 == \"string\" || type2 == \"number\" || type2 == \"atom\") return cont(afterType);\n        if (type2 == \"[\") return cont(pushlex(\"]\"), commasep(typeexpr, \"]\", \",\"), poplex, afterType);\n        if (type2 == \"{\") return cont(pushlex(\"}\"), typeprops, poplex, afterType);\n        if (type2 == \"(\") return cont(commasep(typearg, \")\"), maybeReturnType, afterType);\n        if (type2 == \"<\") return cont(commasep(typeexpr, \">\"), typeexpr);\n        if (type2 == \"quasi\") {\n          return pass(quasiType, afterType);\n        }\n      }\n      function maybeReturnType(type2) {\n        if (type2 == \"=>\") return cont(typeexpr);\n      }\n      function typeprops(type2) {\n        if (type2.match(/[\\}\\)\\]]/)) return cont();\n        if (type2 == \",\" || type2 == \";\") return cont(typeprops);\n        return pass(typeprop, typeprops);\n      }\n      function typeprop(type2, value) {\n        if (type2 == \"variable\" || cx.style == \"keyword\") {\n          cx.marked = \"property\";\n          return cont(typeprop);\n        } else if (value == \"?\" || type2 == \"number\" || type2 == \"string\") {\n          return cont(typeprop);\n        } else if (type2 == \":\") {\n          return cont(typeexpr);\n        } else if (type2 == \"[\") {\n          return cont(expect(\"variable\"), maybetypeOrIn, expect(\"]\"), typeprop);\n        } else if (type2 == \"(\") {\n          return pass(functiondecl, typeprop);\n        } else if (!type2.match(/[;\\}\\)\\],]/)) {\n          return cont();\n        }\n      }\n      function quasiType(type2, value) {\n        if (type2 != \"quasi\") return pass();\n        if (value.slice(value.length - 2) != \"${\") return cont(quasiType);\n        return cont(typeexpr, continueQuasiType);\n      }\n      function continueQuasiType(type2) {\n        if (type2 == \"}\") {\n          cx.marked = \"string-2\";\n          cx.state.tokenize = tokenQuasi;\n          return cont(quasiType);\n        }\n      }\n      function typearg(type2, value) {\n        if (type2 == \"variable\" && cx.stream.match(/^\\s*[?:]/, false) || value == \"?\") return cont(typearg);\n        if (type2 == \":\") return cont(typeexpr);\n        if (type2 == \"spread\") return cont(typearg);\n        return pass(typeexpr);\n      }\n      function afterType(type2, value) {\n        if (value == \"<\") return cont(pushlex(\">\"), commasep(typeexpr, \">\"), poplex, afterType);\n        if (value == \"|\" || type2 == \".\" || value == \"&\") return cont(typeexpr);\n        if (type2 == \"[\") return cont(typeexpr, expect(\"]\"), afterType);\n        if (value == \"extends\" || value == \"implements\") {\n          cx.marked = \"keyword\";\n          return cont(typeexpr);\n        }\n        if (value == \"?\") return cont(typeexpr, expect(\":\"), typeexpr);\n      }\n      function maybeTypeArgs(_, value) {\n        if (value == \"<\") return cont(pushlex(\">\"), commasep(typeexpr, \">\"), poplex, afterType);\n      }\n      function typeparam() {\n        return pass(typeexpr, maybeTypeDefault);\n      }\n      function maybeTypeDefault(_, value) {\n        if (value == \"=\") return cont(typeexpr);\n      }\n      function vardef(_, value) {\n        if (value == \"enum\") {\n          cx.marked = \"keyword\";\n          return cont(enumdef);\n        }\n        return pass(pattern, maybetype, maybeAssign, vardefCont);\n      }\n      function pattern(type2, value) {\n        if (isTS && isModifier(value)) {\n          cx.marked = \"keyword\";\n          return cont(pattern);\n        }\n        if (type2 == \"variable\") {\n          register(value);\n          return cont();\n        }\n        if (type2 == \"spread\") return cont(pattern);\n        if (type2 == \"[\") return contCommasep(eltpattern, \"]\");\n        if (type2 == \"{\") return contCommasep(proppattern, \"}\");\n      }\n      function proppattern(type2, value) {\n        if (type2 == \"variable\" && !cx.stream.match(/^\\s*:/, false)) {\n          register(value);\n          return cont(maybeAssign);\n        }\n        if (type2 == \"variable\") cx.marked = \"property\";\n        if (type2 == \"spread\") return cont(pattern);\n        if (type2 == \"}\") return pass();\n        if (type2 == \"[\") return cont(expression, expect(\"]\"), expect(\":\"), proppattern);\n        return cont(expect(\":\"), pattern, maybeAssign);\n      }\n      function eltpattern() {\n        return pass(pattern, maybeAssign);\n      }\n      function maybeAssign(_type, value) {\n        if (value == \"=\") return cont(expressionNoComma);\n      }\n      function vardefCont(type2) {\n        if (type2 == \",\") return cont(vardef);\n      }\n      function maybeelse(type2, value) {\n        if (type2 == \"keyword b\" && value == \"else\") return cont(pushlex(\"form\", \"else\"), statement, poplex);\n      }\n      function forspec(type2, value) {\n        if (value == \"await\") return cont(forspec);\n        if (type2 == \"(\") return cont(pushlex(\")\"), forspec1, poplex);\n      }\n      function forspec1(type2) {\n        if (type2 == \"var\") return cont(vardef, forspec2);\n        if (type2 == \"variable\") return cont(forspec2);\n        return pass(forspec2);\n      }\n      function forspec2(type2, value) {\n        if (type2 == \")\") return cont();\n        if (type2 == \";\") return cont(forspec2);\n        if (value == \"in\" || value == \"of\") {\n          cx.marked = \"keyword\";\n          return cont(expression, forspec2);\n        }\n        return pass(expression, forspec2);\n      }\n      function functiondef(type2, value) {\n        if (value == \"*\") {\n          cx.marked = \"keyword\";\n          return cont(functiondef);\n        }\n        if (type2 == \"variable\") {\n          register(value);\n          return cont(functiondef);\n        }\n        if (type2 == \"(\") return cont(pushcontext, pushlex(\")\"), commasep(funarg, \")\"), poplex, mayberettype, statement, popcontext);\n        if (isTS && value == \"<\") return cont(pushlex(\">\"), commasep(typeparam, \">\"), poplex, functiondef);\n      }\n      function functiondecl(type2, value) {\n        if (value == \"*\") {\n          cx.marked = \"keyword\";\n          return cont(functiondecl);\n        }\n        if (type2 == \"variable\") {\n          register(value);\n          return cont(functiondecl);\n        }\n        if (type2 == \"(\") return cont(pushcontext, pushlex(\")\"), commasep(funarg, \")\"), poplex, mayberettype, popcontext);\n        if (isTS && value == \"<\") return cont(pushlex(\">\"), commasep(typeparam, \">\"), poplex, functiondecl);\n      }\n      function typename(type2, value) {\n        if (type2 == \"keyword\" || type2 == \"variable\") {\n          cx.marked = \"type\";\n          return cont(typename);\n        } else if (value == \"<\") {\n          return cont(pushlex(\">\"), commasep(typeparam, \">\"), poplex);\n        }\n      }\n      function funarg(type2, value) {\n        if (value == \"@\") cont(expression, funarg);\n        if (type2 == \"spread\") return cont(funarg);\n        if (isTS && isModifier(value)) {\n          cx.marked = \"keyword\";\n          return cont(funarg);\n        }\n        if (isTS && type2 == \"this\") return cont(maybetype, maybeAssign);\n        return pass(pattern, maybetype, maybeAssign);\n      }\n      function classExpression(type2, value) {\n        if (type2 == \"variable\") return className(type2, value);\n        return classNameAfter(type2, value);\n      }\n      function className(type2, value) {\n        if (type2 == \"variable\") {\n          register(value);\n          return cont(classNameAfter);\n        }\n      }\n      function classNameAfter(type2, value) {\n        if (value == \"<\") return cont(pushlex(\">\"), commasep(typeparam, \">\"), poplex, classNameAfter);\n        if (value == \"extends\" || value == \"implements\" || isTS && type2 == \",\") {\n          if (value == \"implements\") cx.marked = \"keyword\";\n          return cont(isTS ? typeexpr : expression, classNameAfter);\n        }\n        if (type2 == \"{\") return cont(pushlex(\"}\"), classBody, poplex);\n      }\n      function classBody(type2, value) {\n        if (type2 == \"async\" || type2 == \"variable\" && (value == \"static\" || value == \"get\" || value == \"set\" || isTS && isModifier(value)) && cx.stream.match(/^\\s+[\\w$\\xa1-\\uffff]/, false)) {\n          cx.marked = \"keyword\";\n          return cont(classBody);\n        }\n        if (type2 == \"variable\" || cx.style == \"keyword\") {\n          cx.marked = \"property\";\n          return cont(classfield, classBody);\n        }\n        if (type2 == \"number\" || type2 == \"string\") return cont(classfield, classBody);\n        if (type2 == \"[\")\n          return cont(expression, maybetype, expect(\"]\"), classfield, classBody);\n        if (value == \"*\") {\n          cx.marked = \"keyword\";\n          return cont(classBody);\n        }\n        if (isTS && type2 == \"(\") return pass(functiondecl, classBody);\n        if (type2 == \";\" || type2 == \",\") return cont(classBody);\n        if (type2 == \"}\") return cont();\n        if (value == \"@\") return cont(expression, classBody);\n      }\n      function classfield(type2, value) {\n        if (value == \"!\") return cont(classfield);\n        if (value == \"?\") return cont(classfield);\n        if (type2 == \":\") return cont(typeexpr, maybeAssign);\n        if (value == \"=\") return cont(expressionNoComma);\n        var context = cx.state.lexical.prev, isInterface = context && context.info == \"interface\";\n        return pass(isInterface ? functiondecl : functiondef);\n      }\n      function afterExport(type2, value) {\n        if (value == \"*\") {\n          cx.marked = \"keyword\";\n          return cont(maybeFrom, expect(\";\"));\n        }\n        if (value == \"default\") {\n          cx.marked = \"keyword\";\n          return cont(expression, expect(\";\"));\n        }\n        if (type2 == \"{\") return cont(commasep(exportField, \"}\"), maybeFrom, expect(\";\"));\n        return pass(statement);\n      }\n      function exportField(type2, value) {\n        if (value == \"as\") {\n          cx.marked = \"keyword\";\n          return cont(expect(\"variable\"));\n        }\n        if (type2 == \"variable\") return pass(expressionNoComma, exportField);\n      }\n      function afterImport(type2) {\n        if (type2 == \"string\") return cont();\n        if (type2 == \"(\") return pass(expression);\n        if (type2 == \".\") return pass(maybeoperatorComma);\n        return pass(importSpec, maybeMoreImports, maybeFrom);\n      }\n      function importSpec(type2, value) {\n        if (type2 == \"{\") return contCommasep(importSpec, \"}\");\n        if (type2 == \"variable\") register(value);\n        if (value == \"*\") cx.marked = \"keyword\";\n        return cont(maybeAs);\n      }\n      function maybeMoreImports(type2) {\n        if (type2 == \",\") return cont(importSpec, maybeMoreImports);\n      }\n      function maybeAs(_type, value) {\n        if (value == \"as\") {\n          cx.marked = \"keyword\";\n          return cont(importSpec);\n        }\n      }\n      function maybeFrom(_type, value) {\n        if (value == \"from\") {\n          cx.marked = \"keyword\";\n          return cont(expression);\n        }\n      }\n      function arrayLiteral(type2) {\n        if (type2 == \"]\") return cont();\n        return pass(commasep(expressionNoComma, \"]\"));\n      }\n      function enumdef() {\n        return pass(pushlex(\"form\"), pattern, expect(\"{\"), pushlex(\"}\"), commasep(enummember, \"}\"), poplex, poplex);\n      }\n      function enummember() {\n        return pass(pattern, maybeAssign);\n      }\n      function isContinuedStatement(state, textAfter) {\n        return state.lastType == \"operator\" || state.lastType == \",\" || isOperatorChar.test(textAfter.charAt(0)) || /[,.]/.test(textAfter.charAt(0));\n      }\n      function expressionAllowed(stream, state, backUp) {\n        return state.tokenize == tokenBase && /^(?:operator|sof|keyword [bcd]|case|new|export|default|spread|[\\[{}\\(,;:]|=>)$/.test(state.lastType) || state.lastType == \"quasi\" && /\\{\\s*$/.test(stream.string.slice(0, stream.pos - (backUp || 0)));\n      }\n      return {\n        startState: function(basecolumn) {\n          var state = {\n            tokenize: tokenBase,\n            lastType: \"sof\",\n            cc: [],\n            lexical: new JSLexical((basecolumn || 0) - indentUnit, 0, \"block\", false),\n            localVars: parserConfig.localVars,\n            context: parserConfig.localVars && new Context(null, null, false),\n            indented: basecolumn || 0\n          };\n          if (parserConfig.globalVars && typeof parserConfig.globalVars == \"object\")\n            state.globalVars = parserConfig.globalVars;\n          return state;\n        },\n        token: function(stream, state) {\n          if (stream.sol()) {\n            if (!state.lexical.hasOwnProperty(\"align\"))\n              state.lexical.align = false;\n            state.indented = stream.indentation();\n            findFatArrow(stream, state);\n          }\n          if (state.tokenize != tokenComment && stream.eatSpace()) return null;\n          var style = state.tokenize(stream, state);\n          if (type == \"comment\") return style;\n          state.lastType = type == \"operator\" && (content == \"++\" || content == \"--\") ? \"incdec\" : type;\n          return parseJS(state, style, type, content, stream);\n        },\n        indent: function(state, textAfter) {\n          if (state.tokenize == tokenComment || state.tokenize == tokenQuasi) return CodeMirror.Pass;\n          if (state.tokenize != tokenBase) return 0;\n          var firstChar = textAfter && textAfter.charAt(0), lexical = state.lexical, top;\n          if (!/^\\s*else\\b/.test(textAfter)) for (var i = state.cc.length - 1; i >= 0; --i) {\n            var c = state.cc[i];\n            if (c == poplex) lexical = lexical.prev;\n            else if (c != maybeelse && c != popcontext) break;\n          }\n          while ((lexical.type == \"stat\" || lexical.type == \"form\") && (firstChar == \"}\" || (top = state.cc[state.cc.length - 1]) && (top == maybeoperatorComma || top == maybeoperatorNoComma) && !/^[,\\.=+\\-*:?[\\(]/.test(textAfter)))\n            lexical = lexical.prev;\n          if (statementIndent && lexical.type == \")\" && lexical.prev.type == \"stat\")\n            lexical = lexical.prev;\n          var type2 = lexical.type, closing = firstChar == type2;\n          if (type2 == \"vardef\") return lexical.indented + (state.lastType == \"operator\" || state.lastType == \",\" ? lexical.info.length + 1 : 0);\n          else if (type2 == \"form\" && firstChar == \"{\") return lexical.indented;\n          else if (type2 == \"form\") return lexical.indented + indentUnit;\n          else if (type2 == \"stat\")\n            return lexical.indented + (isContinuedStatement(state, textAfter) ? statementIndent || indentUnit : 0);\n          else if (lexical.info == \"switch\" && !closing && parserConfig.doubleIndentSwitch != false)\n            return lexical.indented + (/^(?:case|default)\\b/.test(textAfter) ? indentUnit : 2 * indentUnit);\n          else if (lexical.align) return lexical.column + (closing ? 0 : 1);\n          else return lexical.indented + (closing ? 0 : indentUnit);\n        },\n        electricInput: /^\\s*(?:case .*?:|default:|\\{|\\})$/,\n        blockCommentStart: jsonMode ? null : \"/*\",\n        blockCommentEnd: jsonMode ? null : \"*/\",\n        blockCommentContinue: jsonMode ? null : \" * \",\n        lineComment: jsonMode ? null : \"//\",\n        fold: \"brace\",\n        closeBrackets: \"()[]{}''\\\"\\\"``\",\n        helperType: jsonMode ? \"json\" : \"javascript\",\n        jsonldMode,\n        jsonMode,\n        expressionAllowed,\n        skipExpression: function(state) {\n          parseJS(state, \"atom\", \"atom\", \"true\", new CodeMirror.StringStream(\"\", 2, null));\n        }\n      };\n    });\n    CodeMirror.registerHelper(\"wordChars\", \"javascript\", /[\\w$]/);\n    CodeMirror.defineMIME(\"text/javascript\", \"javascript\");\n    CodeMirror.defineMIME(\"text/ecmascript\", \"javascript\");\n    CodeMirror.defineMIME(\"application/javascript\", \"javascript\");\n    CodeMirror.defineMIME(\"application/x-javascript\", \"javascript\");\n    CodeMirror.defineMIME(\"application/ecmascript\", \"javascript\");\n    CodeMirror.defineMIME(\"application/json\", { name: \"javascript\", json: true });\n    CodeMirror.defineMIME(\"application/x-json\", { name: \"javascript\", json: true });\n    CodeMirror.defineMIME(\"application/manifest+json\", { name: \"javascript\", json: true });\n    CodeMirror.defineMIME(\"application/ld+json\", { name: \"javascript\", jsonld: true });\n    CodeMirror.defineMIME(\"text/typescript\", { name: \"javascript\", typescript: true });\n    CodeMirror.defineMIME(\"application/typescript\", { name: \"javascript\", typescript: true });\n  });\n})();\nvar javascriptExports = javascript$2.exports;\nconst javascript = /* @__PURE__ */ getDefaultExportFromCjs(javascriptExports);\nconst javascript$1 = /* @__PURE__ */ _mergeNamespaces({\n  __proto__: null,\n  default: javascript\n}, [javascriptExports]);\nexport {\n  javascript$1 as j\n};\n//# sourceMappingURL=javascript.es.js.map\n"],"names":["_mergeNamespaces","n","m","i","e","k","d","javascript$2","module","exports","mod","CodeMirror","config","parserConfig","indentUnit","statementIndent","jsonldMode","jsonMode","trackScope","isTS","wordRE","keywords","kw","type2","A","B","C","D","operator","atom","isOperatorChar","isJsonldKeyword","readRegexp","stream","escaped","next","inSet","type","content","ret","tp","style","cont2","tokenBase","state","ch","tokenString","tokenComment","expressionAllowed","tokenQuasi","word","quote","maybeEnd","brackets","findFatArrow","arrow","depth","sawSomething","pos","bracket","atomicTypes","JSLexical","indented","column","align","prev","info","inScope","varname","v","cx2","parseJS","content2","cc","cx","combinator","expression","statement","pass","cont","inList","name","list","register","newContext","registerVarScoped","Var","context","inner","Context","isModifier","vars","block2","defaultVars","pushcontext","pushblockcontext","popcontext","pushlex","result","indent","outer","poplex","expect","wanted","exp","value","vardef","parenExpr","maybeexpression","block","maybeelse","functiondef","forspec","className","enumdef","typename","typeexpr","pattern","maybelabel","maybeCatchBinding","afterExport","afterImport","funarg","expressionInner","expressionNoComma","noComma","body","arrowBodyNoComma","arrowBody","commasep","maybeop","maybeoperatorNoComma","maybeoperatorComma","classExpression","arrayLiteral","contCommasep","objprop","quasi","maybeTarget","me","expr","property","continueQuasi","targetNoComma","target","maybeTypeArgs","_","getterSetter","afterprop","maybetype","what","end","sep","proceed","lex","type3","value2","maybetypeOrIn","mayberettype","isKW","afterType","typeprops","typearg","maybeReturnType","quasiType","typeprop","functiondecl","continueQuasiType","typeparam","maybeTypeDefault","maybeAssign","vardefCont","eltpattern","proppattern","_type","forspec1","forspec2","classNameAfter","classBody","classfield","isInterface","maybeFrom","exportField","importSpec","maybeMoreImports","maybeAs","enummember","isContinuedStatement","textAfter","backUp","basecolumn","firstChar","lexical","top","c","closing","javascriptExports","javascript$1"],"sourceRoot":""}