{"version":3,"file":"performStitching.cjs.js","sources":["../../../../src/database/operations/stitcher/performStitching.ts"],"sourcesContent":["/*\n * Copyright 2023 The Backstage Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { ENTITY_STATUS_CATALOG_PROCESSING_TYPE } from '@backstage/catalog-client';\nimport {\n  ANNOTATION_EDIT_URL,\n  ANNOTATION_VIEW_URL,\n  EntityRelation,\n} from '@backstage/catalog-model';\nimport { AlphaEntity, EntityStatusItem } from '@backstage/catalog-model/alpha';\nimport { SerializedError } from '@backstage/errors';\nimport { Knex } from 'knex';\nimport { v4 as uuid } from 'uuid';\nimport { StitchingStrategy } from '../../../stitching/types';\nimport {\n  DbFinalEntitiesRow,\n  DbRefreshStateRow,\n  DbSearchRow,\n} from '../../tables';\nimport { buildEntitySearch } from './buildEntitySearch';\nimport { markDeferredStitchCompleted } from './markDeferredStitchCompleted';\nimport { BATCH_SIZE, generateStableHash } from './util';\nimport { LoggerService } from '@backstage/backend-plugin-api';\n\n// See https://github.com/facebook/react/blob/f0cf832e1d0c8544c36aa8b310960885a11a847c/packages/react-dom-bindings/src/shared/sanitizeURL.js\nconst scriptProtocolPattern =\n  // eslint-disable-next-line no-control-regex\n  /^[\\u0000-\\u001F ]*j[\\r\\n\\t]*a[\\r\\n\\t]*v[\\r\\n\\t]*a[\\r\\n\\t]*s[\\r\\n\\t]*c[\\r\\n\\t]*r[\\r\\n\\t]*i[\\r\\n\\t]*p[\\r\\n\\t]*t[\\r\\n\\t]*\\:/i;\n\n/**\n * Performs the act of stitching - to take all of the various outputs from the\n * ingestion process, and stitching them together into the final entity JSON\n * shape.\n */\nexport async function performStitching(options: {\n  knex: Knex | Knex.Transaction;\n  logger: LoggerService;\n  strategy: StitchingStrategy;\n  entityRef: string;\n  stitchTicket?: string;\n}): Promise<'changed' | 'unchanged' | 'abandoned'> {\n  const { knex, logger, entityRef } = options;\n  const stitchTicket = options.stitchTicket ?? uuid();\n\n  const entityResult = await knex<DbRefreshStateRow>('refresh_state')\n    .where({ entity_ref: entityRef })\n    .limit(1)\n    .select('entity_id');\n  if (!entityResult.length) {\n    // Entity does no exist in refresh state table, no stitching required.\n    return 'abandoned';\n  }\n\n  // Insert stitching ticket that will be compared before inserting the final entity.\n  await knex<DbFinalEntitiesRow>('final_entities')\n    .insert({\n      entity_id: entityResult[0].entity_id,\n      hash: '',\n      entity_ref: entityRef,\n      stitch_ticket: stitchTicket,\n    })\n    .onConflict('entity_id')\n    .merge(['stitch_ticket']);\n\n  // Selecting from refresh_state and final_entities should yield exactly\n  // one row (except in abnormal cases where the stitch was invoked for\n  // something that didn't exist at all, in which case it's zero rows).\n  // The join with the temporary incoming_references still gives one row.\n  const [processedResult, relationsResult] = await Promise.all([\n    knex\n      .with('incoming_references', function incomingReferences(builder) {\n        return builder\n          .from('refresh_state_references')\n          .where({ target_entity_ref: entityRef })\n          .count({ count: '*' });\n      })\n      .select({\n        entityId: 'refresh_state.entity_id',\n        processedEntity: 'refresh_state.processed_entity',\n        errors: 'refresh_state.errors',\n        incomingReferenceCount: 'incoming_references.count',\n        previousHash: 'final_entities.hash',\n      })\n      .from('refresh_state')\n      .where({ 'refresh_state.entity_ref': entityRef })\n      .crossJoin(knex.raw('incoming_references'))\n      .leftOuterJoin('final_entities', {\n        'final_entities.entity_id': 'refresh_state.entity_id',\n      }),\n    knex\n      .distinct({\n        relationType: 'type',\n        relationTarget: 'target_entity_ref',\n      })\n      .from('relations')\n      .where({ source_entity_ref: entityRef })\n      .orderBy('relationType', 'asc')\n      .orderBy('relationTarget', 'asc'),\n  ]);\n\n  // If there were no rows returned, it would mean that there was no\n  // matching row even in the refresh_state. This can happen for example\n  // if we emit a relation to something that hasn't been ingested yet.\n  // It's safe to ignore this stitch attempt in that case.\n  if (!processedResult.length) {\n    logger.debug(\n      `Unable to stitch ${entityRef}, item does not exist in refresh state table`,\n    );\n    return 'abandoned';\n  }\n\n  const {\n    entityId,\n    processedEntity,\n    errors,\n    incomingReferenceCount,\n    previousHash,\n  } = processedResult[0];\n\n  // If there was no processed entity in place, the target hasn't been\n  // through the processing steps yet. It's safe to ignore this stitch\n  // attempt in that case, since another stitch will be triggered when\n  // that processing has finished.\n  if (!processedEntity) {\n    logger.debug(\n      `Unable to stitch ${entityRef}, the entity has not yet been processed`,\n    );\n    return 'abandoned';\n  }\n\n  // Grab the processed entity and stitch all of the relevant data into\n  // it\n  const entity = JSON.parse(processedEntity) as AlphaEntity;\n  const isOrphan = Number(incomingReferenceCount) === 0;\n  let statusItems: EntityStatusItem[] = [];\n\n  if (isOrphan) {\n    logger.debug(`${entityRef} is an orphan`);\n    entity.metadata.annotations = {\n      ...entity.metadata.annotations,\n      ['backstage.io/orphan']: 'true',\n    };\n  }\n  if (errors) {\n    const parsedErrors = JSON.parse(errors) as SerializedError[];\n    if (Array.isArray(parsedErrors) && parsedErrors.length) {\n      statusItems = parsedErrors.map(e => ({\n        type: ENTITY_STATUS_CATALOG_PROCESSING_TYPE,\n        level: 'error',\n        message: `${e.name}: ${e.message}`,\n        error: e,\n      }));\n    }\n  }\n  // We opt to do this check here as we otherwise can't guarantee that it will be run after all processors\n  for (const annotation of [ANNOTATION_VIEW_URL, ANNOTATION_EDIT_URL]) {\n    const value = entity.metadata.annotations?.[annotation];\n    if (typeof value === 'string' && scriptProtocolPattern.test(value)) {\n      entity.metadata.annotations![annotation] =\n        'https://backstage.io/annotation-rejected-for-security-reasons';\n    }\n  }\n\n  // TODO: entityRef is lower case and should be uppercase in the final\n  // result\n  entity.relations = relationsResult\n    .filter(row => row.relationType /* exclude null row, if relevant */)\n    .map<EntityRelation>(row => ({\n      type: row.relationType!,\n      targetRef: row.relationTarget!,\n    }));\n  if (statusItems.length) {\n    entity.status = {\n      ...entity.status,\n      items: [...(entity.status?.items ?? []), ...statusItems],\n    };\n  }\n\n  // If the output entity was actually not changed, just abort\n  const hash = generateStableHash(entity);\n  if (hash === previousHash) {\n    logger.debug(`Skipped stitching of ${entityRef}, no changes`);\n    return 'unchanged';\n  }\n\n  entity.metadata.uid = entityId;\n  if (!entity.metadata.etag) {\n    // If the original data source did not have its own etag handling,\n    // use the hash as a good-quality etag\n    entity.metadata.etag = hash;\n  }\n\n  // This may throw if the entity is invalid, so we call it before\n  // the final_entities write, even though we may end up not needing\n  // to write the search index.\n  const searchEntries = buildEntitySearch(entityId, entity);\n\n  const amountOfRowsChanged = await knex<DbFinalEntitiesRow>('final_entities')\n    .update({\n      final_entity: JSON.stringify(entity),\n      hash,\n      last_updated_at: knex.fn.now(),\n      entity_ref: entityRef,\n    })\n    .where('entity_id', entityId)\n    .where('stitch_ticket', stitchTicket)\n    .onConflict('entity_id')\n    .merge(['final_entity', 'hash', 'last_updated_at']);\n\n  const markDeferred = async () => {\n    if (options.strategy.mode !== 'deferred') {\n      return;\n    }\n    await markDeferredStitchCompleted({\n      knex: knex,\n      entityRef,\n      stitchTicket,\n    });\n  };\n\n  if (amountOfRowsChanged === 0) {\n    logger.debug(`Entity ${entityRef} is already stitched, skipping write.`);\n    await markDeferred();\n    return 'abandoned';\n  }\n\n  await knex.transaction(async trx => {\n    await trx<DbSearchRow>('search').where({ entity_id: entityId }).delete();\n    await trx.batchInsert('search', searchEntries, BATCH_SIZE);\n  });\n\n  await markDeferred();\n  return 'changed';\n}\n"],"names":["uuid","ENTITY_STATUS_CATALOG_PROCESSING_TYPE","ANNOTATION_VIEW_URL","ANNOTATION_EDIT_URL","generateStableHash","buildEntitySearch","markDeferredStitchCompleted","BATCH_SIZE"],"mappings":"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"}